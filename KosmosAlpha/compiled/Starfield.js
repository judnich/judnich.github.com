//@ sourceMappingURL=Starfield.map
// Generated by CoffeeScript 1.6.1
(function() {
  var root, starBufferSize, universeSeed;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  universeSeed = 31415;

  starBufferSize = 10000;

  root.Starfield = (function() {

    function Starfield(blockMinStars, blockMaxStars, blockScale, starSize, viewRange) {
      var buff, i, j, k, pos, uv, w, x, y, z, _i, _j, _k, _l, _len, _ref, _ref1, _ref2, _ref3, _ref4, _ref5;
      this.blockMinStars = blockMinStars;
      this.blockMaxStars = blockMaxStars;
      this.blockScale = blockScale;
      this.viewRange = viewRange;
      this.starSize = starSize;
      this.randomStream = new RandomStream(universeSeed);
      console.log("Generating stars...");
      this.shader = xgl.loadProgram("starfield");
      this.shader.uniforms = xgl.getProgramUniforms(this.shader, ["modelViewMat", "projMat", "starSizeAndViewRange"]);
      this.shader.attribs = xgl.getProgramAttribs(this.shader, ["aPos", "aUV"]);
      this.starPositions = [];
      for (i = _i = 0, _ref = starBufferSize - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        pos = [this.randomStream.unit(), this.randomStream.unit(), this.randomStream.unit(), this.randomStream.unit()];
        this.starPositions[i] = pos;
      }
      buff = new Float32Array(starBufferSize * 4 * 6);
      j = 0;
      for (i = _j = 0, _ref1 = starBufferSize - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _ref2 = this.starPositions[i], x = _ref2[0], y = _ref2[1], z = _ref2[2], w = _ref2[3];
        _ref3 = [[0, 0], [0, 1], [1, 0], [1, 1]];
        for (_k = 0, _len = _ref3.length; _k < _len; _k++) {
          uv = _ref3[_k];
          buff[j] = x;
          buff[j + 1] = y;
          buff[j + 2] = z;
          buff[j + 3] = w;
          buff[j + 4] = uv[0];
          buff[j + 5] = uv[1];
          j += 6;
        }
      }
      this.vBuff = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vBuff);
      gl.bufferData(gl.ARRAY_BUFFER, buff, gl.STATIC_DRAW);
      this.vBuff.itemSize = 6;
      this.vBuff.numItems = starBufferSize * 4;
      buff = new Uint16Array(starBufferSize * 6);
      for (i = _l = 0, _ref4 = starBufferSize - 1; 0 <= _ref4 ? _l <= _ref4 : _l >= _ref4; i = 0 <= _ref4 ? ++_l : --_l) {
        _ref5 = [i * 6, i * 4], j = _ref5[0], k = _ref5[1];
        buff[j] = k + 0;
        buff[j + 1] = k + 1;
        buff[j + 2] = k + 2;
        buff[j + 3] = k + 1;
        buff[j + 4] = k + 3;
        buff[j + 5] = k + 2;
      }
      this.iBuff = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuff);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, buff, gl.STATIC_DRAW);
      this.iBuff.itemSize = 1;
      this.iBuff.numItems = starBufferSize * 6;
      if (this.iBuff.numItems >= 0xFFFF) {
        xgl.error("Index buffer too large for StarField");
      }
      console.log("All stars generated.");
    }

    Starfield.prototype.render = function(camera, gridOffset) {
      var bpos, ci, cj, ck, i, j, k, minDist, r, rstr, seed, _i, _j, _k, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6;
      this._startRender();
      _ref = [Math.floor(camera.position[0] / this.blockScale), Math.floor(camera.position[1] / this.blockScale), Math.floor(camera.position[2] / this.blockScale)], ci = _ref[0], cj = _ref[1], ck = _ref[2];
      r = Math.ceil(this.viewRange / this.blockScale);
      for (i = _i = _ref1 = ci - r, _ref2 = ci + r; _ref1 <= _ref2 ? _i <= _ref2 : _i >= _ref2; i = _ref1 <= _ref2 ? ++_i : --_i) {
        for (j = _j = _ref3 = cj - r, _ref4 = cj + r; _ref3 <= _ref4 ? _j <= _ref4 : _j >= _ref4; j = _ref3 <= _ref4 ? ++_j : --_j) {
          for (k = _k = _ref5 = ck - r, _ref6 = ck + r; _ref5 <= _ref6 ? _k <= _ref6 : _k >= _ref6; k = _ref5 <= _ref6 ? ++_k : --_k) {
            bpos = vec3.fromValues((i + 0.5) * this.blockScale, (j + 0.5) * this.blockScale, (k + 0.5) * this.blockScale);
            minDist = vec3.distance(camera.position, bpos) - this.blockScale * 0.8660254;
            if (minDist <= this.viewRange) {
              seed = ((i + gridOffset[0]) * 7) + ((j + gridOffset[1]) * 65537) + ((k + gridOffset[2]) * 257);
              rstr = new root.RandomStream(seed);
              this._renderBlock(camera, seed, rstr.range(this.blockMinStars, this.blockMaxStars), i, j, k);
            }
          }
        }
      }
      return this._finishRender();
    };

    Starfield.prototype._startRender = function() {
      gl.disable(gl.DEPTH_TEST);
      gl.depthMask(false);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE);
      gl.useProgram(this.shader);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vBuff);
      gl.enableVertexAttribArray(this.shader.attribs.aPos);
      gl.vertexAttribPointer(this.shader.attribs.aPos, 4, gl.FLOAT, false, this.vBuff.itemSize * 4, 0);
      gl.enableVertexAttribArray(this.shader.attribs.aUV);
      gl.vertexAttribPointer(this.shader.attribs.aUV, 2, gl.FLOAT, false, this.vBuff.itemSize * 4, 4 * 4);
      return gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuff);
    };

    Starfield.prototype._finishRender = function() {
      gl.disableVertexAttribArray(this.shader.attribs.aPos);
      gl.disableVertexAttribArray(this.shader.attribs.aUV);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.useProgram(null);
      gl.enable(gl.DEPTH_TEST);
      gl.depthMask(true);
      return gl.disable(gl.BLEND);
    };

    Starfield.prototype._renderBlock = function(camera, seed, starCount, i, j, k) {
      var box, modelViewMat, offset;
      box = new Box();
      box.min = vec3.fromValues(i * this.blockScale, j * this.blockScale, k * this.blockScale);
      box.max = vec3.fromValues((i + 1) * this.blockScale, (j + 1) * this.blockScale, (k + 1) * this.blockScale);
      if (!camera.isVisibleBox(box)) {
        return;
      }
      if (starCount <= 0) {
        return;
      }
      starCount = Math.floor(starCount);
      seed = Math.floor(Math.abs(seed));
      if (starCount * 6 > this.iBuff.numItems) {
        starCount = this.iBuff.numItems / 6;
        console.log("Warning: Too many stars requested of starfield block render operation");
      }
      if (starBufferSize > starCount) {
        offset = ((seed + 127) * 65537) % (1 + starBufferSize - starCount);
      } else {
        offset = 0;
      }
      modelViewMat = mat4.create();
      mat4.scale(modelViewMat, modelViewMat, vec3.fromValues(this.blockScale, this.blockScale, this.blockScale));
      mat4.translate(modelViewMat, modelViewMat, vec3.fromValues(i, j, k));
      mat4.mul(modelViewMat, camera.viewMat, modelViewMat);
      gl.uniformMatrix4fv(this.shader.uniforms.projMat, false, camera.projMat);
      gl.uniformMatrix4fv(this.shader.uniforms.modelViewMat, false, modelViewMat);
      gl.uniform2f(this.shader.uniforms.starSizeAndViewRange, this.starSize, this.viewRange);
      return gl.drawElements(gl.TRIANGLES, starCount * 6, gl.UNSIGNED_SHORT, 2 * 6 * offset);
    };

    return Starfield;

  })();

}).call(this);
