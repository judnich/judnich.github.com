//@ sourceMappingURL=Planetfield.map
// Generated by CoffeeScript 1.6.1
(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.planetBufferSize = 10;

  root.Planetfield = (function() {

    function Planetfield(_arg) {
      var angle, farRange, i, j, marker, nearRange, planetSize, randAngle, randomStream, starfield, u, v, vi, _i, _j, _ref;
      starfield = _arg.starfield, planetSize = _arg.planetSize, nearRange = _arg.nearRange, farRange = _arg.farRange;
      this.starfield = starfield;
      this.nearRange = nearRange;
      this.farRange = farRange;
      this.planetSize = planetSize;
      this.starfield = starfield;
      this._planetBufferSize = planetBufferSize;
      randomStream = new RandomStream(universeSeed);
      this.shader = xgl.loadProgram("planetfield");
      this.shader.uniforms = xgl.getProgramUniforms(this.shader, ["modelViewMat", "projMat", "spriteSizeAndViewRangeAndBlur"]);
      this.shader.attribs = xgl.getProgramAttribs(this.shader, ["aPos", "aUV"]);
      this.iBuff = this.starfield.iBuff;
      if (this._planetBufferSize * 6 > this.iBuff.numItems) {
        console.log("Warning: planetBufferSize should not be larger than starBufferSize. Setting planetBufferSize = starBufferSize.");
        this._planetBufferSize = this.iBuff.numItems;
      }
      this.buff = new Float32Array(this._planetBufferSize * 4 * 6);
      j = 0;
      for (i = _i = 0, _ref = this._planetBufferSize - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        randAngle = randomStream.range(0, Math.PI * 2);
        for (vi = _j = 0; _j <= 3; vi = ++_j) {
          angle = ((vi - 0.5) / 2.0) * Math.PI + randAngle;
          u = Math.sin(angle) * Math.sqrt(2) * 0.5;
          v = Math.cos(angle) * Math.sqrt(2) * 0.5;
          marker = vi <= 1 ? 1 : -1;
          this.buff[j + 3] = u;
          this.buff[j + 4] = v;
          this.buff[j + 5] = marker;
          j += 6;
        }
      }
      this.vBuff = gl.createBuffer();
      this.vBuff.itemSize = 6;
      this.vBuff.numItems = this._planetBufferSize * 4;
    }

    Planetfield.prototype.setPlanetSprite = function(index, position) {
      var j, vi, _i, _results;
      if (index >= this._planetBufferSize) {
        console.log("Internal error: Planet index exceeds planet buffer size");
        return;
      }
      j = index * 6 * 4;
      _results = [];
      for (vi = _i = 0; _i <= 3; vi = ++_i) {
        this.buff[j] = position[0];
        this.buff[j + 1] = position[1];
        this.buff[j + 2] = position[2];
        _results.push(j += 6);
      }
      return _results;
    };

    Planetfield.prototype.render = function(camera, originOffset, blur) {
      var i, numPlanets, randomStream, seed, _i, _ref;
      numPlanets = 10;
      randomStream = new RandomStream(0);
      for (i = _i = 0, _ref = numPlanets - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.setPlanetSprite(i, [randomStream.range(-1000, 1000) - originOffset[0], randomStream.range(-1000, 1000) - originOffset[1], randomStream.range(-1000, 1000) - originOffset[2]]);
      }
      if (numPlanets <= 0) {
        return;
      }
      this._startRender();
      gl.bufferData(gl.ARRAY_BUFFER, this.buff, gl.DYNAMIC_DRAW);
      this.vBuff.usedItems = Math.floor(this.vBuff.usedItems);
      if (this.vBuff.usedItems <= 0) {
        return;
      }
      seed = Math.floor(Math.abs(seed));
      gl.uniformMatrix4fv(this.shader.uniforms.projMat, false, camera.projMat);
      gl.uniformMatrix4fv(this.shader.uniforms.modelViewMat, false, camera.viewMat);
      gl.uniform4f(this.shader.uniforms.spriteSizeAndViewRangeAndBlur, this.planetSize, this.nearRange, this.farRange, blur);
      gl.drawElements(gl.TRIANGLES, numPlanets * 6, gl.UNSIGNED_SHORT, 0);
      return this._finishRender();
    };

    Planetfield.prototype._startRender = function() {
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.CULL_FACE);
      gl.depthMask(false);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE);
      gl.useProgram(this.shader);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vBuff);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuff);
      gl.enableVertexAttribArray(this.shader.attribs.aPos);
      gl.vertexAttribPointer(this.shader.attribs.aPos, 3, gl.FLOAT, false, this.vBuff.itemSize * 4, 0);
      gl.enableVertexAttribArray(this.shader.attribs.aUV);
      return gl.vertexAttribPointer(this.shader.attribs.aUV, 3, gl.FLOAT, false, this.vBuff.itemSize * 4, 4 * 3);
    };

    Planetfield.prototype._finishRender = function() {
      gl.disableVertexAttribArray(this.shader.attribs.aPos);
      gl.disableVertexAttribArray(this.shader.attribs.aUV);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.useProgram(null);
      gl.disable(gl.BLEND);
      gl.depthMask(true);
      gl.enable(gl.DEPTH_TEST);
      return gl.enable(gl.CULL_FACE);
    };

    return Planetfield;

  })();

}).call(this);
