//@ sourceMappingURL=Planetfield.map
// Generated by CoffeeScript 1.6.1
(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.planetBufferSize = 100;

  root.Planetfield = (function() {

    function Planetfield(_arg) {
      var angle, farRange, generateCallback, i, j, marker, maxOrbitScale, maxPlanetsPerSystem, minOrbitScale, nearRange, planetSize, randAngle, randomStream, starfield, u, v, vi, _i, _j, _ref;
      starfield = _arg.starfield, maxPlanetsPerSystem = _arg.maxPlanetsPerSystem, minOrbitScale = _arg.minOrbitScale, maxOrbitScale = _arg.maxOrbitScale, planetSize = _arg.planetSize, nearRange = _arg.nearRange, farRange = _arg.farRange;
      this._starfield = starfield;
      this._planetBufferSize = root.planetBufferSize;
      this.nearRange = nearRange;
      this.farRange = farRange;
      this.planetSize = planetSize;
      this.maxPlanetsPerSystem = maxPlanetsPerSystem;
      this.minOrbitScale = minOrbitScale;
      this.maxOrbitScale = maxOrbitScale;
      randomStream = new RandomStream(universeSeed);
      this.shader = xgl.loadProgram("planetfield");
      this.shader.uniforms = xgl.getProgramUniforms(this.shader, ["modelViewMat", "projMat", "spriteSizeAndViewRangeAndBlur"]);
      this.shader.attribs = xgl.getProgramAttribs(this.shader, ["aPos", "aUV"]);
      this.iBuff = this._starfield.iBuff;
      if (this._planetBufferSize * 6 > this.iBuff.numItems) {
        console.log("Warning: planetBufferSize should not be larger than starBufferSize. Setting planetBufferSize = starBufferSize.");
        this._planetBufferSize = this.iBuff.numItems;
      }
      this.buff = new Float32Array(this._planetBufferSize * 4 * 6);
      j = 0;
      for (i = _i = 0, _ref = this._planetBufferSize - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        randAngle = randomStream.range(0, Math.PI * 2);
        for (vi = _j = 0; _j <= 3; vi = ++_j) {
          angle = ((vi - 0.5) / 2.0) * Math.PI + randAngle;
          u = Math.sin(angle) * Math.sqrt(2) * 0.5;
          v = Math.cos(angle) * Math.sqrt(2) * 0.5;
          marker = vi <= 1 ? 1 : -1;
          this.buff[j + 3] = u;
          this.buff[j + 4] = v;
          this.buff[j + 5] = marker;
          j += 6;
        }
      }
      this.vBuff = gl.createBuffer();
      this.vBuff.itemSize = 6;
      this.vBuff.numItems = this._planetBufferSize * 4;
      this.farMesh = new PlanetFarMesh(8);
      this.farMapGen = new FarMapGenerator(512);
      generateCallback = (function(gen) {
        return function(seed) {
          return gen.generate(seed);
        };
      })(this.farMapGen);
      this.farMapCache = new ContentCache(16, generateCallback);
    }

    Planetfield.prototype.setPlanetSprite = function(index, position) {
      var j, vi, _i, _results;
      j = index * 6 * 4;
      _results = [];
      for (vi = _i = 0; _i <= 3; vi = ++_i) {
        this.buff[j] = position[0];
        this.buff[j + 1] = position[1];
        this.buff[j + 2] = position[2];
        _results.push(j += 6);
      }
      return _results;
    };

    Planetfield.prototype.render = function(camera, originOffset, blur) {
      this.starList = this._starfield.queryStars(camera.position, originOffset, this.farRange);
      this.starList.sort(function(_arg, _arg1) {
        var aw, ax, ay, az, cw, cx, cy, cz;
        ax = _arg[0], ay = _arg[1], az = _arg[2], aw = _arg[3];
        cx = _arg1[0], cy = _arg1[1], cz = _arg1[2], cw = _arg1[3];
        return (ax * ax + ay * ay + az * az) - (cx * cx + cy * cy + cz * cz);
      });
      this.generatePlanetPositions();
      camera.far = this.farRange * 1.1;
      camera.near = this.nearRange * 0.9;
      camera.update();
      this.renderSprites(camera, originOffset, blur);
      camera.far = this.nearRange * 5.0;
      camera.near = this.nearRange * 0.001;
      camera.update();
      this.renderFarMeshes(camera, originOffset);
      this.farMapGen.start();
      this.farMapCache.update(1);
      return this.farMapGen.finish();
    };

    Planetfield.prototype.generatePlanetPositions = function() {
      var alpha, angle, dist, dx, dy, dz, i, numMeshPlanets, pw, radius, randomStream, systemPlanets, w, x, y, z, _i, _len, _ref, _ref1, _results;
      randomStream = new RandomStream();
      this.numPlanets = 0;
      this.meshPlanets = [];
      numMeshPlanets = 0;
      _ref = this.starList;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], dx = _ref1[0], dy = _ref1[1], dz = _ref1[2], w = _ref1[3];
        randomStream.seed = Math.floor(w * 1000000);
        systemPlanets = randomStream.intRange(0, this.maxPlanetsPerSystem);
        if (this.numPlanets + systemPlanets > this._planetBufferSize) {
          break;
        }
        _results.push((function() {
          var _j, _ref2, _results1;
          _results1 = [];
          for (i = _j = 1; 1 <= systemPlanets ? _j <= systemPlanets : _j >= systemPlanets; i = 1 <= systemPlanets ? ++_j : --_j) {
            radius = this._starfield.starSize * randomStream.range(this.minOrbitScale, this.maxOrbitScale);
            angle = randomStream.radianAngle();
            _ref2 = [dx + radius * Math.sin(angle), dy + radius * Math.cos(angle), dz + w * Math.sin(angle)], x = _ref2[0], y = _ref2[1], z = _ref2[2];
            dist = Math.sqrt(x * x + y * y + z * z);
            alpha = 2.0 - (dist / this.nearRange) * 0.5;
            pw = randomStream.unit();
            if (alpha > 0.001) {
              this.meshPlanets[numMeshPlanets] = [x, y, z, pw, alpha];
              numMeshPlanets++;
            }
            this.setPlanetSprite(this.numPlanets, [x, y, z]);
            _results1.push(this.numPlanets++);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Planetfield.prototype.renderFarMeshes = function(camera, originOffset) {
      var alpha, globalPos, i, lightCenter, lightPos, lightVec, localPos, seed, star, textureMap, w, x, y, z, _i, _j, _ref, _ref1, _ref2, _ref3;
      if (!this.meshPlanets || this.meshPlanets.length === 0 || this.starList.length === 0) {
        return;
      }
      this.farMesh.startRender();
      lightCenter = vec3.fromValues(this.starList[0][0], this.starList[0][1], this.starList[0][2]);
      for (i = _i = 1, _ref = Math.min(2, this.starList.length); 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        star = this.starList[i];
        lightPos = vec3.fromValues(star[0], star[1], star[2]);
        if (Math.abs(1.0 - (vec3.distance(lightPos, lightCenter) / vec3.length(lightCenter))) < 0.5) {
          vec3.scale(lightCenter, lightCenter, 0.75);
          vec3.scale(lightPos, lightPos, 0.25);
          vec3.add(lightCenter, lightCenter, lightPos);
        }
      }
      _ref1 = [vec3.create(), vec3.create(), vec3.create()], localPos = _ref1[0], globalPos = _ref1[1], lightVec = _ref1[2];
      for (i = _j = _ref2 = this.meshPlanets.length - 1; _ref2 <= 0 ? _j <= 0 : _j >= 0; i = _ref2 <= 0 ? ++_j : --_j) {
        _ref3 = this.meshPlanets[i], x = _ref3[0], y = _ref3[1], z = _ref3[2], w = _ref3[3], alpha = _ref3[4];
        localPos = vec3.fromValues(x, y, z);
        vec3.add(globalPos, localPos, camera.position);
        vec3.subtract(lightVec, lightCenter, localPos);
        vec3.normalize(lightVec, lightVec);
        seed = Math.floor(w * 1000000);
        textureMap = this.farMapCache.getContent(seed);
        this.farMesh.renderInstance(camera, globalPos, lightVec, alpha, textureMap);
      }
      return this.farMesh.finishRender();
    };

    Planetfield.prototype.renderSprites = function(camera, originOffset, blur) {
      var modelViewMat, seed;
      if (this.numPlanets <= 0) {
        return;
      }
      this._startRenderSprites();
      gl.bufferData(gl.ARRAY_BUFFER, this.buff, gl.DYNAMIC_DRAW);
      this.vBuff.usedItems = Math.floor(this.vBuff.usedItems);
      if (this.vBuff.usedItems <= 0) {
        return;
      }
      seed = Math.floor(Math.abs(seed));
      modelViewMat = mat4.create();
      mat4.translate(modelViewMat, modelViewMat, camera.position);
      mat4.mul(modelViewMat, camera.viewMat, modelViewMat);
      gl.uniformMatrix4fv(this.shader.uniforms.projMat, false, camera.projMat);
      gl.uniformMatrix4fv(this.shader.uniforms.modelViewMat, false, modelViewMat);
      gl.uniform4f(this.shader.uniforms.spriteSizeAndViewRangeAndBlur, this.planetSize * 10.0, this.nearRange, this.farRange, blur);
      gl.drawElements(gl.TRIANGLES, this.numPlanets * 6, gl.UNSIGNED_SHORT, 0);
      return this._finishRenderSprites();
    };

    Planetfield.prototype._startRenderSprites = function() {
      gl.disable(gl.DEPTH_TEST);
      gl.disable(gl.CULL_FACE);
      gl.depthMask(false);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE);
      gl.useProgram(this.shader);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.vBuff);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.iBuff);
      gl.enableVertexAttribArray(this.shader.attribs.aPos);
      gl.vertexAttribPointer(this.shader.attribs.aPos, 3, gl.FLOAT, false, this.vBuff.itemSize * 4, 0);
      gl.enableVertexAttribArray(this.shader.attribs.aUV);
      return gl.vertexAttribPointer(this.shader.attribs.aUV, 3, gl.FLOAT, false, this.vBuff.itemSize * 4, 4 * 3);
    };

    Planetfield.prototype._finishRenderSprites = function() {
      gl.disableVertexAttribArray(this.shader.attribs.aPos);
      gl.disableVertexAttribArray(this.shader.attribs.aUV);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);
      gl.useProgram(null);
      gl.disable(gl.BLEND);
      gl.depthMask(true);
      gl.enable(gl.DEPTH_TEST);
      return gl.enable(gl.CULL_FACE);
    };

    return Planetfield;

  })();

}).call(this);
