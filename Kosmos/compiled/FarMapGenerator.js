//@ sourceMappingURL=FarMapGenerator.map
// Generated by CoffeeScript 1.6.1
(function() {
  var root;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.FarMapGenerator = (function() {

    function FarMapGenerator(mapResolution) {
      var binormal, buff, faceIndex, i, pos, posU, posV, tangent, uv, _i, _j, _k, _len, _ref, _ref1;
      this.shader = [];
      for (i = _i = 0, _ref = kosmosShaderHeightFunctions.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.shader[i] = xgl.loadProgram("farMapGenerator" + i);
        this.shader[i].uniforms = xgl.getProgramUniforms(this.shader[i], ["randomSeed"]);
        this.shader[i].attribs = xgl.getProgramAttribs(this.shader[i], ["aUV", "aPos", "aTangent", "aBinormal"]);
      }
      this.fbo = gl.createFramebuffer();
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
      this.fbo.width = mapResolution * 6;
      this.fbo.height = mapResolution;
      console.log("Initialized low resolution planet map generator FBO at " + this.fbo.width + " x " + this.fbo.height);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      buff = new Float32Array(6 * 6 * 11);
      i = 0;
      tangent = [0, 0, 0];
      binormal = [0, 0, 0];
      for (faceIndex = _j = 0; _j <= 5; faceIndex = ++_j) {
        _ref1 = [[0, 0], [1, 0], [0, 1], [1, 0], [1, 1], [0, 1]];
        for (_k = 0, _len = _ref1.length; _k < _len; _k++) {
          uv = _ref1[_k];
          pos = mapPlaneToCube(uv[0], uv[1], faceIndex);
          buff[i++] = (uv[0] + faceIndex) / 6.0;
          buff[i++] = uv[1];
          buff[i++] = pos[0];
          buff[i++] = pos[1];
          buff[i++] = pos[2];
          posU = mapPlaneToCube(uv[0] + 1, uv[1], faceIndex);
          posV = mapPlaneToCube(uv[0], uv[1] + 1, faceIndex);
          binormal = [posU[0] - pos[0], posU[1] - pos[1], posU[2] - pos[2]];
          tangent = [posV[0] - pos[0], posV[1] - pos[1], posV[2] - pos[2]];
          buff[i++] = binormal[0];
          buff[i++] = binormal[1];
          buff[i++] = binormal[2];
          buff[i++] = tangent[0];
          buff[i++] = tangent[1];
          buff[i++] = tangent[2];
        }
      }
      this.quadVerts = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVerts);
      gl.bufferData(gl.ARRAY_BUFFER, buff, gl.STATIC_DRAW);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      this.quadVerts.itemSize = 11;
      this.quadVerts.numItems = buff.length / this.quadVerts.itemSize;
    }

    FarMapGenerator.prototype.start = function() {
      gl.disable(gl.DEPTH_TEST);
      gl.depthMask(false);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this.fbo);
      gl.viewport(0, 0, this.fbo.width, this.fbo.height);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.quadVerts);
      gl.enableVertexAttribArray(this.shader[0].attribs.aUV);
      gl.enableVertexAttribArray(this.shader[0].attribs.aPos);
      gl.enableVertexAttribArray(this.shader[0].attribs.aBinormal);
      return gl.enableVertexAttribArray(this.shader[0].attribs.aTangent);
    };

    FarMapGenerator.prototype.finish = function() {
      gl.disableVertexAttribArray(this.shader[0].attribs.aUV);
      gl.disableVertexAttribArray(this.shader[0].attribs.aPos);
      gl.disableVertexAttribArray(this.shader[0].attribs.aBinormal);
      gl.disableVertexAttribArray(this.shader[0].attribs.aTangent);
      gl.bindBuffer(gl.ARRAY_BUFFER, null);
      gl.bindFramebuffer(gl.FRAMEBUFFER, null);
      gl.useProgram(null);
      gl.depthMask(true);
      return gl.enable(gl.DEPTH_TEST);
    };

    FarMapGenerator.prototype.generate = function(seed) {
      var heightMap, rndStr, seeds, shaderIndex;
      rndStr = new RandomStream(seed);
      seeds = [rndStr.unit(), rndStr.unit(), rndStr.unit(), rndStr.unit()];
      shaderIndex = rndStr.intRange(0, kosmosShaderHeightFunctions.length - 1);
      console.log("Using planet category " + shaderIndex);
      gl.useProgram(this.shader[shaderIndex]);
      gl.vertexAttribPointer(this.shader[shaderIndex].attribs.aUV, 2, gl.FLOAT, false, this.quadVerts.itemSize * 4, 0);
      gl.vertexAttribPointer(this.shader[shaderIndex].attribs.aPos, 3, gl.FLOAT, false, this.quadVerts.itemSize * 4, 4 * 2);
      gl.vertexAttribPointer(this.shader[shaderIndex].attribs.aBinormal, 3, gl.FLOAT, false, this.quadVerts.itemSize * 4, 4 * 5);
      gl.vertexAttribPointer(this.shader[shaderIndex].attribs.aTangent, 3, gl.FLOAT, false, this.quadVerts.itemSize * 4, 4 * 8);
      gl.uniform4fv(this.shader[shaderIndex].uniforms.randomSeed, seeds);
      heightMap = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, heightMap);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, this.fbo.width, this.fbo.height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
      gl.bindTexture(gl.TEXTURE_2D, null);
      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, heightMap, 0);
      gl.drawArrays(gl.TRIANGLES, 0, this.quadVerts.numItems);
      return heightMap;
    };

    return FarMapGenerator;

  })();

}).call(this);
